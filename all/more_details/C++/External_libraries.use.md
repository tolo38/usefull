Note about external libraries

.lib : (windows) Stactic libraries 
> it can be either static libraries (containing object files) or import libraries (containing symbols to allow the linker to link to a DLL).

> it put the executable code for that function in a library, and the linker can extract and insert the compiled code into your program. 

.dll : (windows) dynamic libraries : it containes the active binary. 
> Rather than building the library code into your program when it is compiled, it can be run by mapping it into your program as it is loaded into memory. 
> Multiple programs running at the same time that use the same functions can all share one copy, saving memory.

.a.: (unix){static} Archive libraries
> .a files are static libraries typically generated by the archive tool. You usually include the header files associated with that static library and then link to the library when you are compiling.
usually located under `lib/` directory.

.so : (unix){dynamic} Shared object

.h : header


You don't link against a dll. You link against the import library (.lib)
and then the DLL must be available to your application at runtime.


With static libraries :
If there's any change in library, you need to compile and build your code again.

unix :
* `ldd` command helps to investigate dependancies
* to analyse code content `nm` or for dynamic lib specificaly : `readelf`
* for addressing versionning investigation, linking issues : `ld`

windows :
[lucasg/Dependencies](https://github.com/lucasg/Dependencies/issues) provide similare functionnalities, and GUI


Plug-ins (or runtime (un)/loadablable lib ) with `libdl`

Exemple :
```C++
#ifndef USE_PRECOMPILED_HEADERS
#ifdef WIN32
#include <direct.h>
#include <windows.h>
#else
#include <sys/types.h>
#include <dlfcn.h>
#endif
#include <iostream>
#endif

    using namespace std;

#ifdef WIN32
    HINSTANCE lib_handle;
#else
    void *lib_handle;
#endif

    // Where retType is the pointer to a return type of the function
    // This return type can be int, float, double, etc or a struct or class.

    typedef retType* func_t;  

    // load the library -------------------------------------------------
#ifdef WIN32
    string nameOfLibToLoad("C:\opt\lib\libctest.dll");
    lib_handle = LoadLibrary(TEXT(nameOfLibToLoad.c_str()));
    if (!lib_handle) {
        cerr << "Cannot load library: " << TEXT(nameOfDllToLoad.c_str()) << endl;
    }
#else
    string nameOfLibToLoad("/opt/lib/libctest.so");
    lib_handle = dlopen(nameOfLibToLoad.c_str(), RTLD_LAZY);
    if (!lib_handle) {
        cerr << "Cannot load library: " << dlerror() << endl;
    }
#endif

...
...
...

    // load the symbols -------------------------------------------------
#ifdef WIN32
    func_t* fn_handle = (func_t*) GetProcAddress(lib_handle, "superfunctionx");
    if (!fn_handle) {
        cerr << "Cannot load symbol superfunctionx: " << GetLastError() << endl;
    }
#else
    // reset errors
    dlerror();

    // load the symbols (handle to function "superfunctionx")
    func_t* fn_handle= (func_t*) dlsym(lib_handle, "superfunctionx");
    const char* dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol superfunctionx: " << dlsym_error << endl;
    }
#endif

...
...
...

    // unload the library -----------------------------------------------

#ifdef WIN32
    FreeLibrary(lib_handle);
#else
    dlclose(lib_handle);
#endif
```



C++ issues (for compatibility with C) : name mangling

[reference link](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)
